<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>E-commerce Image Creator</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            gap: 20px;
            padding: 20px;
            background-color: #f0f0f0;
        }
        #controls {
            width: 350px;
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            align-self: flex-start;
            flex-shrink: 0;
        }
        #controls h2, #controls h3 {
            margin-top: 0;
            color: #333;
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 0.9em;
            color: #555;
        }
        .control-group input[type="number"],
        .control-group input[type="color"],
        .control-group input[type="range"],
        .control-group select,
        .control-group input[type="file"] {
            width: calc(100% - 12px);
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }
        .control-group input[type="color"] {
            padding: 2px;
            height: 35px;
        }
        .inline-inputs {
            display: flex;
            gap: 10px;
        }
        .inline-inputs > div {
            flex: 1;
        }
        #canvas-container {
            flex: 1;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            padding: 10px;
            background-color: #e9e9e9;
            border-radius: 8px;
            min-height: 200px;
            align-content: flex-start;
        }

        .canvas-item-wrapper {
            width: calc((100% - 2 * 15px) / 3);
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 5px;
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .canvas-item-wrapper canvas {
            border: 1px solid #ccc;
            max-width: 100%;
            height: auto;
            display: block;
        }
        .download-icon {
            margin-top: 8px;
            padding: 5px 8px;
            font-size: 1.2em;
            text-decoration: none;
            color: #007bff;
            border: 1px solid #007bff;
            border-radius: 4px;
            transition: background-color 0.2s, color 0.2s;
        }
        .download-icon:hover {
            background-color: #007bff;
            color: white;
        }

        #alpha-value {
            display: inline-block;
            margin-left: 10px;
            font-size: 0.9em;
        }
    </style>
</head>
<body>

<div id="controls">
    <h2>Image Controls</h2>
    <div class="control-group">
        <label for="image-upload">Upload PNG Images (up to 200):</label>
        <input type="file" id="image-upload" accept="image/png" multiple>
    </div>
    <h3>Canvas Settings (Full Resolution)</h3>
    <div class="control-group">
        <label>Canvas Size (px):</label>
        <div class="inline-inputs">
            <div><label for="canvas-width" style="font-size:0.8em; font-weight:normal;">Width:</label><input type="number" id="canvas-width" value="800" min="50"></div>
            <div><label for="canvas-height" style="font-size:0.8em; font-weight:normal;">Height:</label><input type="number" id="canvas-height" value="600" min="50"></div>
        </div>
         <small>Display will be capped at 500px on longer side.</small>
    </div>
    <div class="control-group">
        <label for="bg-color">Background Color:</label><input type="color" id="bg-color" value="#FFFFFF">
    </div>
    <div class="control-group">
        <label for="bg-alpha">Background Alpha: <span id="alpha-value">1.0</span></label>
        <input type="range" id="bg-alpha" min="0" max="1" step="0.01" value="1">
    </div>
    <h3>Margins (%)</h3>
    <div class="control-group">
        <div class="inline-inputs">
            <div><label for="margin-top" style="font-size:0.8em; font-weight:normal;">Top:</label><input type="number" id="margin-top" value="10" min="0" max="49"></div>
            <div><label for="margin-bottom" style="font-size:0.8em; font-weight:normal;">Bottom:</label><input type="number" id="margin-bottom" value="10" min="0" max="49"></div>
        </div>
        <div class="inline-inputs" style="margin-top: 5px;">
            <div><label for="margin-left" style="font-size:0.8em; font-weight:normal;">Left:</label><input type="number" id="margin-left" value="10" min="0" max="49"></div>
            <div><label for="margin-right" style="font-size:0.8em; font-weight:normal;">Right:</label><input type="number" id="margin-right" value="10" min="0" max="49"></div>
        </div>
    </div>
    <h3>Justification</h3>
    <div class="control-group">
        <div class="inline-inputs">
            <div><label for="h-justify">Horizontal:</label><select id="h-justify"><option value="center" selected>Center</option><option value="left">Left</option><option value="right">Right</option></select></div>
            <div><label for="v-justify">Vertical:</label><select id="v-justify"><option value="center" selected>Center</option><option value="top">Top</option><option value="bottom">Bottom</option></select></div>
        </div>
    </div>
     <button id="apply-all" style="width:100%; padding:10px; background-color: #007bff; color:white; border:none; border-radius:4px; cursor:pointer;">Apply All Settings</button>
</div>

<div id="canvas-container">
    <!-- Canvas item wrappers will be appended here -->
</div>

<script>
    const imageUpload = document.getElementById('image-upload');
    const canvasContainer = document.getElementById('canvas-container');

    const canvasWidthInput = document.getElementById('canvas-width');
    const canvasHeightInput = document.getElementById('canvas-height');
    const bgColorInput = document.getElementById('bg-color');
    const bgAlphaInput = document.getElementById('bg-alpha');
    const alphaValueSpan = document.getElementById('alpha-value');
    const marginTopInput = document.getElementById('margin-top');
    const marginBottomInput = document.getElementById('margin-bottom');
    const marginLeftInput = document.getElementById('margin-left');
    const marginRightInput = document.getElementById('margin-right');
    const hJustifySelect = document.getElementById('h-justify');
    const vJustifySelect = document.getElementById('v-justify');
    const applyAllButton = document.getElementById('apply-all');

    let productImages = [];
    let imageCounter = 0;
    const MAX_IMAGES = 200;
    const MAX_DISPLAY_SIDE = 500; // Max pixels for the longer side of the display canvas

    function getGlobalSettings() {
        const r = parseInt(bgColorInput.value.slice(1, 3), 16);
        const g = parseInt(bgColorInput.value.slice(3, 5), 16);
        const b = parseInt(bgColorInput.value.slice(5, 7), 16);
        const a = parseFloat(bgAlphaInput.value);

        return {
            requestedWidth: parseInt(canvasWidthInput.value), // User's desired full width
            requestedHeight: parseInt(canvasHeightInput.value), // User's desired full height
            bgColor: `rgba(${r}, ${g}, ${b}, ${a})`,
            marginTop: parseInt(marginTopInput.value),
            marginBottom: parseInt(marginBottomInput.value),
            marginLeft: parseInt(marginLeftInput.value),
            marginRight: parseInt(marginRightInput.value),
            hJustify: hJustifySelect.value,
            vJustify: vJustifySelect.value,
        };
    }

    function calculateDisplayDimensions(requestedWidth, requestedHeight, maxDimension) {
        let displayWidth = requestedWidth;
        let displayHeight = requestedHeight;
        let scaleFactor = 1.0;

        const longerSide = Math.max(requestedWidth, requestedHeight);

        if (longerSide > maxDimension && maxDimension > 0) {
            scaleFactor = maxDimension / longerSide;
            displayWidth = Math.round(requestedWidth * scaleFactor);
            displayHeight = Math.round(requestedHeight * scaleFactor);
        }
        
        // Ensure minimum dimensions to avoid issues with 0 or negative values
        displayWidth = Math.max(1, displayWidth);
        displayHeight = Math.max(1, displayHeight);

        return {
            width: displayWidth,
            height: displayHeight,
            scaleFactor: scaleFactor 
        };
    }
    
    bgAlphaInput.addEventListener('input', () => {
        alphaValueSpan.textContent = parseFloat(bgAlphaInput.value).toFixed(2);
    });

    function drawCheckerboard(ctx, widthForPattern, heightForPattern, squaresOnLongerDimension = 20) {
        ctx.save();
        if (widthForPattern <= 0 || heightForPattern <= 0 || squaresOnLongerDimension <= 0) {
            ctx.restore(); return;
        }
        let squarePixelSize = (widthForPattern >= heightForPattern) 
                              ? widthForPattern / squaresOnLongerDimension 
                              : heightForPattern / squaresOnLongerDimension;
        squarePixelSize = Math.max(1, squarePixelSize);
        const numCols = Math.ceil(widthForPattern / squarePixelSize);
        const numRows = Math.ceil(heightForPattern / squarePixelSize);
        for (let row = 0; row < numRows; row++) {
            for (let col = 0; col < numCols; col++) {
                ctx.fillStyle = ((row + col) % 2 === 0) ? '#e0e0e0' : '#ffffff';
                ctx.fillRect(col * squarePixelSize, row * squarePixelSize, squarePixelSize, squarePixelSize);
            }
        }
        ctx.restore();
    }

    /**
     * Draws on a canvas or a context.
     * @param {string|CanvasRenderingContext2D} target - Canvas ID or a 2D rendering context.
     * @param {Image} imageElement - The image to draw.
     * @param {object} fullResSettings - Global settings object with user's full resolution choices.
     * @param {number} renderWidth - The actual width to render the canvas at (for display or download).
     * @param {number} renderHeight - The actual height to render the canvas at.
     * @param {boolean} [skipCheckerboard=false] - If true, checkerboard pattern is skipped.
     */
    function drawOnCanvas(target, imageElement, fullResSettings, renderWidth, renderHeight, skipCheckerboard = false) {
        let canvas;
        let ctx;

        if (typeof target === 'string') { // target is canvasId (for on-screen display)
            canvas = document.getElementById(target);
            if (!canvas || !imageElement || !imageElement.complete || imageElement.naturalWidth === 0) {
                return;
            }
            // Set the actual drawing buffer size for the on-screen canvas
            canvas.width = renderWidth;
            canvas.height = renderHeight;
            ctx = canvas.getContext('2d');
        } else { // target is a CanvasRenderingContext2D (for offscreen rendering for download)
            ctx = target;
            canvas = ctx.canvas; // canvas.width/height already set by caller for offscreen
        }

        // 1. Draw Checkerboard background (conditional)
        if (!skipCheckerboard) {
            drawCheckerboard(ctx, renderWidth, renderHeight); // Use renderWidth/Height for checkerboard
        }

        // 2. Draw actual background color (with alpha)
        ctx.fillStyle = fullResSettings.bgColor;
        ctx.fillRect(0, 0, renderWidth, renderHeight);

        // 3. Calculate margins in pixels based on render dimensions
        const marginTopPx = renderHeight * (fullResSettings.marginTop / 100);
        const marginBottomPx = renderHeight * (fullResSettings.marginBottom / 100);
        const marginLeftPx = renderWidth * (fullResSettings.marginLeft / 100);
        const marginRightPx = renderWidth * (fullResSettings.marginRight / 100);

        // 4. Calculate drawable area based on render dimensions
        const drawableWidth = renderWidth - marginLeftPx - marginRightPx;
        const drawableHeight = renderHeight - marginTopPx - marginBottomPx;

        if (drawableWidth <= 0 || drawableHeight <= 0) return;
        
        // 5. Scale image to fit within drawable area, preserving aspect ratio
        const imgAspectRatio = imageElement.naturalWidth / imageElement.naturalHeight;
        let scaledWidth, scaledHeight;

        if (drawableWidth / drawableHeight > imgAspectRatio) {
            scaledHeight = drawableHeight;
            scaledWidth = scaledHeight * imgAspectRatio;
        } else {
            scaledWidth = drawableWidth;
            scaledHeight = scaledWidth / imgAspectRatio;
        }
        scaledWidth = Math.max(0, scaledWidth);
        scaledHeight = Math.max(0, scaledHeight);

        // 6. Calculate image position based on justification
        let x = marginLeftPx;
        let y = marginTopPx;
        const hSpace = drawableWidth - scaledWidth;
        if (hSpace > 0.1) {
             switch (fullResSettings.hJustify) {
                case 'left': x += 0; break;
                case 'center': x += hSpace / 2; break;
                case 'right': x += hSpace; break;
            }
        }
        const vSpace = drawableHeight - scaledHeight;
         if (vSpace > 0.1) {
            switch (fullResSettings.vJustify) {
                case 'top': y += 0; break;
                case 'center': y += vSpace / 2; break;
                case 'bottom': y += vSpace; break;
            }
        }

        // 7. Draw the image
        if (scaledWidth > 0 && scaledHeight > 0) {
             ctx.drawImage(imageElement, x, y, scaledWidth, scaledHeight);
        }
    }

    function updateAndRedrawAll() {
        const currentFullResSettings = getGlobalSettings();
        const displayDims = calculateDisplayDimensions(
            currentFullResSettings.requestedWidth, 
            currentFullResSettings.requestedHeight, 
            MAX_DISPLAY_SIDE
        );

        productImages.forEach(item => {
            drawOnCanvas(
                item.id, 
                item.image, 
                currentFullResSettings, 
                displayDims.width,  // Render at display width
                displayDims.height, // Render at display height
                false // Show checkerboard for display
            );
        });
    }

    function downloadImage(canvasId, imageElement) {
        const fullResSettings = getGlobalSettings(); // Get current full resolution settings
        
        const offscreenCanvas = document.createElement('canvas');
        // Set offscreen canvas to the user's desired full resolution
        offscreenCanvas.width = fullResSettings.requestedWidth;
        offscreenCanvas.height = fullResSettings.requestedHeight;
        const offscreenCtx = offscreenCanvas.getContext('2d');

        // Draw on the offscreen canvas at full resolution, skipping the checkerboard
        drawOnCanvas(
            offscreenCtx, 
            imageElement, 
            fullResSettings, 
            fullResSettings.requestedWidth,  // Render at full width
            fullResSettings.requestedHeight, // Render at full height
            true // Skip checkerboard for download
        );

        const dataURL = offscreenCanvas.toDataURL('image/png');
        const link = document.createElement('a');
        link.href = dataURL;
        let filename = (imageElement.dataset.filename) 
            ? imageElement.dataset.filename.split('.').slice(0, -1).join('.') + "_edited.png"
            : `${canvasId}_edited.png`;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    imageUpload.addEventListener('change', (event) => {
        const files = Array.from(event.target.files);
        const currentFullResSettings = getGlobalSettings(); // For initial draw
        const displayDims = calculateDisplayDimensions( // For initial draw
            currentFullResSettings.requestedWidth, 
            currentFullResSettings.requestedHeight, 
            MAX_DISPLAY_SIDE
        );

        let slotsAvailable = MAX_IMAGES - productImages.length;

        files.slice(0, slotsAvailable).forEach(file => {
            if (productImages.length >= MAX_IMAGES) {
                alert(`Maximum of ${MAX_IMAGES} images reached.`); return;
            }
            if (file.type === "image/png") {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        imageCounter++;
                        const canvasId = `product-canvas-${imageCounter}`;
                        img.dataset.filename = file.name;

                        const wrapperDiv = document.createElement('div');
                        wrapperDiv.className = 'canvas-item-wrapper';
                        const canvas = document.createElement('canvas');
                        canvas.id = canvasId;
                        // canvas.width/height will be set by drawOnCanvas
                        
                        const downloadLink = document.createElement('a');
                        downloadLink.href = "#";
                        downloadLink.className = 'download-icon';
                        downloadLink.innerHTML = '💾';
                        downloadLink.title = `Download ${file.name}`;
                        downloadLink.addEventListener('click', (evt) => {
                            evt.preventDefault();
                            downloadImage(canvasId, img);
                        });

                        wrapperDiv.appendChild(canvas);
                        wrapperDiv.appendChild(downloadLink);
                        canvasContainer.appendChild(wrapperDiv);

                        productImages.push({ id: canvasId, image: img, wrapper: wrapperDiv });
                        // Initial draw for the new image
                        drawOnCanvas(
                            canvasId, 
                            img, 
                            currentFullResSettings, 
                            displayDims.width, 
                            displayDims.height, 
                            false
                        );
                    };
                    img.onerror = () => console.error("Error loading image: " + file.name);
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            } else {
                alert(`File ${file.name} is not a PNG. It will be skipped.`);
            }
        });
        event.target.value = null; 
    });

    [canvasWidthInput, canvasHeightInput, bgColorInput, bgAlphaInput, 
     marginTopInput, marginBottomInput, marginLeftInput, marginRightInput,
     hJustifySelect, vJustifySelect].forEach(input => {
        input.addEventListener('input', updateAndRedrawAll);
    });
    applyAllButton.addEventListener('click', updateAndRedrawAll);
    alphaValueSpan.textContent = parseFloat(bgAlphaInput.value).toFixed(2);

</script>

</body>
</html>